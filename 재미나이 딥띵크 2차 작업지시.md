## 크루즈 가이드 AI '지니(Genie)' - 최종 현실화 실행 계획서 (V3.0)

대표님, 제공해주신 'GPT 계획서 1차안'(심리 기반 UX 전략)과 'Cursor 현실 점검 보고서'(개발 난이도 평가)를 종합적으로 분석했습니다. 이 최종 계획서는 대표님(코딩 초보자)이 커서 AI(Claude 3.5 Sonnet)를 활용하여 **현실적으로 프로젝트를 완성**할 수 있도록 설계된 **초미세 작업 지시서**입니다.

### 0\. 핵심 전략: 현실적인 기술 우회로 선택하기

'현실 점검 보고서'는 RAG(지식 검색 시스템) 구축을 위한 데이터베이스 설정이 초보자에게 거의 불가능하다고 정확히 지적했습니다. 우리는 이 현실을 인정하고 전략을 수정합니다.

1.  **RAG 시스템 혁신 (기술적 우회)**: 복잡한 DB 설정(PostgreSQL/pgvector) 대신, **'인메모리(In-Memory) 벡터 검색'** 방식을 도입합니다. 이는 구현 난이도를 획기적으로 낮추면서도 고품질의 지식 검색을 가능하게 합니다. (예상 지식 문서량 50\~100개에 최적화된 방식입니다.)
2.  **UX는 이상적으로**: GPT가 제안한 50대 고객 맞춤형 UX(대화 우선, 퀵 카드, 안심 제공, 말풍선 회화)를 적극 수용합니다.
3.  **토큰 절약 극대화**: 커서의 `Cmd+K`(Edit) 기능을 최대한 활용하는 방식을 안내합니다.
4.  **대표님은 콘텐츠에 집중**: 기술 구현은 AI에게 맡기고, 대표님은 오직 **크루즈 전문 지식 작성**에 집중합니다.

-----

### 📌 커서(Cursor) AI 사용법 및 토큰 절약 팁 (필독)

토큰 비용을 90% 이상 절약하려면 반드시 **Edit (Cmd+K)** 기능을 사용해야 합니다.

1.  **파일 열기**: 작업 대상 파일을 커서 에디터에서 엽니다. (AI에게 파일 생성을 요청하기보다 직접 파일을 생성하는 것이 좋습니다.)
2.  **코드 선택**: 수정이 필요한 코드 블록을 마우스로 드래그하여 선택합니다. 파일 전체 수정이 필요하면 전체를 선택(`Cmd+A`)합니다.
3.  **Edit 실행**: 키보드에서 `Cmd+K` (Windows는 `Ctrl+K`)를 누릅니다.
4.  **프롬프트 붙여넣기**: 아래 제공되는 '🤖 커서 AI용 프롬프트'를 입력창에 붙여넣고 실행합니다.

> **⚠️ 주의**: 새 채팅창을 열고 요청하면 AI가 전체 맥락을 다시 파악하느라 토큰이 낭비됩니다. 반드시 `Cmd+K`를 사용하세요.

-----

### 🚀 프로젝트 로드맵 재구성 (현실 반영 버전)

  * **Phase 1: 긴급 안정화 및 데이터 기반 확보** (1-2주, 난이도: ⭐⭐)
  * **Phase 2: 핵심 안전 기능 완성 (Return to Ship)** (1주, 난이도: ⭐⭐⭐)
  * **Phase 3: 지식 주입 (콘텐츠 작성 - ⭐대표님 집중 기간⭐)** (2-3주 이상, 난이도: ⭐)
  * **Phase 4: 스마트 RAG 시스템 구현 (단순화 버전)** (1-2주, 난이도: ⭐⭐⭐⭐)
  * **Phase 5: 자동화 및 비즈니스 로직 완성** (1-2주, 난이도: ⭐⭐⭐)

-----

## Phase 1: 긴급 안정화 및 데이터 기반 확보 (1-2주)

가장 시급한 버그(히스토리 유실, 스트리밍 미적용)를 수정하고 데이터 저장 방식을 통일합니다.

#### Task 1.1: 채팅 히스토리 저장 및 로드

📌 **Step 1-1-1: 대화 기록 로드 API 생성 (백엔드)**

  * 🧠 **개발자의 조언**: 사용자가 앱을 다시 켰을 때 이전 대화를 보려면, DB에 저장된 기록을 불러오는 API(데이터 통로)가 필요합니다.
  * 📄 **대상 파일**: `/app/api/chat/history/route.ts` (새 파일 생성 후 진행)

> 🤖 **커서 AI용 프롬프트 (파일 생성 후 전체 선택하여 Cmd+K):**
>
> 새로운 API 엔드포인트 `/app/api/chat/history/route.ts`를 구현합니다. (Next.js App Router 방식 GET 요청)
>
> **요구사항:**
>
> 1.  세션에서 현재 로그인한 사용자의 `userId`와 활성 `tripId`를 확인합니다. (인증 필수, 없으면 401 반환)
> 2.  Prisma `ChatHistory` 테이블에서 해당 기록을 조회합니다.
> 3.  최근 50개 메시지만, `createdAt` 기준으로 오름차순(오래된 순) 정렬합니다.
> 4.  응답 포맷: Vercel AI SDK 호환 형식인 `{id: string, role: 'user' | 'assistant', content: string}[]` 으로 반환합니다.

📌 **Step 1-1-2: 프론트엔드에 히스토리 적용**

  * 🧠 **개발자의 조언**: 이제 만들어진 API를 화면(프론트엔드)에서 호출하여 대화창에 표시해야 합니다. `useChat` 훅의 `initialMessages` 옵션을 사용합니다.
  * 📄 **대상 파일**: 채팅 UI 컴포넌트 (예: `/app/chat/page.tsx` 또는 `ChatClientShell.tsx`)

> 🤖 **커서 AI용 프롬프트 (컴포넌트 코드를 드래그하여 Cmd+K):**
>
> 채팅 화면이 로드될 때 이전 대화 기록을 불러오도록 수정해주세요.
>
> **요구사항:**
>
> 1.  컴포넌트 마운트 시 `/api/chat/history` API를 호출합니다.
> 2.  API 결과를 `useChat` 훅의 `initialMessages` 옵션에 설정해주세요.
> 3.  데이터를 불러오는 동안 "대화 기록 불러오는 중..." 메시지를 표시해주세요.

📌 **Step 1-1-3: 스트리밍 응답 및 저장 로직 구현 (통합)**

  * 🧠 **개발자의 조언**: AI 응답을 실시간(스트리밍)으로 표시하여 UX를 개선하고, 대화가 완료되면 DB에 저장합니다. 스트리밍 완료 시점(`onCompletion`)에 저장하는 것이 중요합니다.
  * 📄 **대상 파일**: `/app/api/chat/route.ts`

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> AI 응답 방식을 스트리밍으로 전환하고, 채팅 기록을 DB에 저장하는 로직을 구현해주세요.
>
> **요구사항:**
>
> 1.  Vercel AI SDK의 `streamText`를 사용합니다. (모델: gemini-2.5-flash 유지). `StreamingTextResponse`로 반환합니다.
> 2.  **사용자 메시지 저장**: 요청 즉시 `ChatHistory`에 저장합니다. (`userId`, `tripId` 포함)
> 3.  **AI 응답 저장**: 스트리밍 완료 후, `streamText`의 `onCompletion` 콜백을 사용하여 최종 응답 내용을 `ChatHistory`에 저장합니다.

#### Task 1.2: 데이터 마이그레이션 (LocalStorage → DB)

  * 🧠 **개발자의 조언**: 가계부와 체크리스트가 기기(LocalStorage)에만 저장되면 AI가 접근할 수 없습니다. 이를 서버 DB로 옮겨야 합니다.

📌 **Step 1-2-1: 가계부(Wallet) 페이지 수정**

  * 📄 **대상 파일**: `/app/wallet/page.tsx`

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> 현재 LocalStorage를 사용하는 로직을 모두 제거하고, 백엔드 API(`/api/expenses`)를 사용하도록 전면 수정해주세요.
>
> **요구사항:**
>
> 1.  조회: 페이지 로드 시 `GET /api/expenses` 호출.
> 2.  추가/수정/삭제: `POST/PUT/DELETE` 요청 사용.
> 3.  API 호출 상태(로딩, 성공, 실패)에 따른 명확한 UI 피드백(예: "저장되었습니다", "오류 발생")을 구현합니다.
> 4.  50대 사용자를 위해 버튼과 입력창을 크고 명확하게 유지해주세요.

*(📌 체크리스트 페이지(`/app/checklist/page.tsx`)도 동일한 방식으로 진행합니다.)*

-----

## Phase 2: 핵심 안전 기능 완성 (Return to Ship) (1주)

고객의 가장 큰 불안인 '배 놓침'을 방지하는 핵심 안전 기능을 구현합니다.

#### Task 2.1: "배로 돌아가기" 배너 구현 (난이도: ⭐⭐⭐)

📌 **Step 2-1-1: 배너 컴포넌트 생성 및 기본 기능 구현**

  * 🧠 **개발자의 조언**: 이 기능은 GPS와 실시간 타이머를 결합합니다. 시각적으로 즉시 인지할 수 있도록 디자인이 중요합니다. (GPT 계획서의 '안전' 강조 반영)
  * 📄 **대상 파일**: `/app/chat/components/ReturnToShipBanner.tsx` (새 파일 생성 후 진행)

> 🤖 **커서 AI용 프롬프트 (파일 생성 후 전체 선택하여 Cmd+K):**
>
> 새로운 컴포넌트 `ReturnToShipBanner.tsx`를 생성합니다. 상단에 고정되는 안전 배너입니다.
>
> **Props 정의:**
>
>   * `allAboardTime`: 승선 마감 시간 (ISO Date string)
>   * `portLocation`: 항구 위치 `{lat: number, lng: number}`
>
> **요구사항 (Tailwind CSS):**
>
> 1.  **카운트다운**: `allAboardTime`까지 남은 시간을 실시간(매초 업데이트) 표시. (예: "승선 마감까지 1시간 15분 30초"). 폰트 크기를 매우 크게(2xl 이상).
> 2.  **경고 시스템**: 60분 미만 시 배경 주황색, 30분 미만 시 배경 빨간색 및 깜박이는 효과 추가.
> 3.  **GPS 추적**: `navigator.geolocation.watchPosition`을 사용하여 현재 위치를 실시간 추적합니다.
> 4.  **권한 처리**: 위치 정보 접근 권한 요청. 실패 시 "위치 서비스를 켜주세요. 길찾기가 불가능합니다." 안내 메시지 표시.
> 5.  **길찾기 버튼**: "구글 지도로 길찾기 (대중교통 우선)" 버튼을 크게 만듭니다.
>     클릭 시 URL 열기: `https://www.google.com/maps/dir/?api=1&origin={현재위치Lat},{현재위치Lng}&destination={항구Lat},{항구Lng}&travelmode=transit`
> 6.  현재 위치를 파악할 수 없을 경우 버튼을 비활성화합니다.

📌 **Step 2-1-2: 배너 조건부 표시 구현**

  * 🧠 **개발자의 조언**: 이 배너는 기항지에 도착했을 때만 보여야 합니다. 현재 여행 일정을 확인하는 로직이 필요합니다.
  * 📄 **대상 파일**: 채팅 메인 화면 (예: `/app/chat/page.tsx` 또는 `ChatInteractiveUI.tsx`)

> 🤖 **커서 AI용 프롬프트 (컴포넌트 코드를 드래그하여 Cmd+K):**
>
> `ReturnToShipBanner`를 통합하고 조건부로 렌더링해주세요.
>
> **요구사항:**
>
> 1.  현재 여행 데이터(Trip, Itinerary)를 가져옵니다. (데이터 로드 방식은 현재 구현에 맞게 조정)
> 2.  **조건 확인**:
>       * 여행 상태가 `InProgress`인가?
>       * 오늘의 일정이 '기항지(Port)'인가?
>       * 현재 시간이 도착 시간 이후이며 승선 마감 시간 이전인가?
> 3.  조건 만족 시, `ReturnToShipBanner`를 화면 최상단에 고정하여 렌더링하고 필요한 Props를 전달합니다.
>     *(주의: 이 기능이 작동하려면 Itinerary 데이터에 항구 좌표와 정확한 시간이 필요합니다.)*

-----

## Phase 3: 지식 주입 (콘텐츠 작성) - ⭐대표님 집중 기간⭐

이 단계는 기술 구현이 아닌, **대표님의 전문성**이 필요한 단계입니다. 프로젝트의 성공 여부가 여기에 달려 있습니다. GPT 계획서의 구조를 바탕으로 최소 50개 이상의 상세한 문서를 목표로 하세요.

#### Task 3.1: 지식 데이터 폴더 구조 생성

프로젝트 루트에 `/knowledge_data` 폴더를 만들고, 아래 구조로 카테고리 폴더를 생성합니다.

```
/knowledge_data
  /A_여행준비       (준비물, 반입금지, 환전/팁, 통신)
  /B_터미널_승선    (짐부치기, 체크인, 안전교육)
  /C_선내생활       (식사, 드레스코드, 시설 이용)
  /D_기항지         (귀선시간, 자유여행 팁)
  /E_하선_정산
  /F_동행유형별팁   (아이 동반, 부모님 동반 등)
  /G_말풍선회화     (상황별 필수 영어)
```

#### Task 3.2: 콘텐츠 작성 (Markdown 형식)

50대 고객의 '용어 공포', '절차 불안', '언어 걱정'을 해소하는 데 집중하여 작성합니다.

**콘텐츠 작성 원칙 (GPT 계획서 반영):**

1.  **쉬운 언어**: 머스터 드릴(X) → 안전 교육(O).
2.  **단계별 설명**: 1), 2), 3) 순서로 명확하게.
3.  **말풍선 회화 포함**: 상황별 간단한 영어를 꼭 포함시킵니다.

**예시: `/knowledge_data/B_터미널_승선/01_짐부치기.md`**

```markdown
# 터미널 도착 후 첫 단계: 짐 부치기 (수하물 위탁)

터미널에 도착하면 가장 먼저 무거운 짐부터 처리해야 합니다. 어렵지 않으니 걱정 마세요.

## 절차 안내

1. **러기지 태그 확인**: 미리 출력해서 캐리어에 붙여둔 '러기지 태그(Luggage Tag)'가 잘 붙어있는지 확인합니다. 이 태그에 객실 번호가 적혀있습니다.
2. **포터에게 전달**: 터미널 입구에 대기 중인 포터(Porter, 짐 운반원)에게 짐을 전달합니다.
3. **짐 이동**: 짐은 객실 앞까지 배달됩니다. (승선 후 1~3시간 소요될 수 있습니다.)

## ⚠️ 주의사항 및 팁

* **귀중품은 직접 소지**: 여권, 지갑, 상비약은 절대로 캐리어에 넣지 말고 작은 손가방에 직접 가지고 타세요!
* **팁 문화**: 미국 등 지역에 따라 포터에게 작은 팁(가방 1개당 1~2달러)을 주는 것이 관례일 수 있습니다.

## 💬 말풍선 회화 (영어로)

* "짐을 부치고 싶어요."
  -> **I'd like to drop off my luggage.**
```

-----

## Phase 4: 스마트 RAG 시스템 구현 (단순화 버전) (1-2주)

작성된 콘텐츠를 AI가 활용할 수 있도록 구현합니다. 복잡한 DB 설정 대신 **인메모리 검색 방식**을 사용합니다. (난이도: ⭐⭐⭐⭐)

#### Task 4.1: 임베딩 생성 준비

📌 **Step 4-1-1: 필요한 패키지 설치**

터미널에서 다음 명령어를 실행합니다. (AI에게 요청하지 않고 직접 실행)

```bash
npm install @google/generative-ai ts-node markdown-it
```

📌 **Step 4-1-2: 임베딩 유틸리티 함수 생성**

  * 🧠 **개발자의 조언**: 텍스트를 AI가 이해할 수 있는 숫자 배열(벡터)로 변환하는 기능입니다. Google API 키 설정이 필요합니다.
  * 📄 **대상 파일**: `/lib/ai/embeddingUtils.ts` (새 파일 생성 후 진행)

> 🤖 **커서 AI용 프롬프트 (파일 생성 후 전체 선택하여 Cmd+K):**
>
> Google Generative AI SDK를 사용하여 텍스트 임베딩을 생성하는 유틸리티 함수를 작성해주세요.
>
> **요구사항:**
>
> 1.  `@google/generative-ai` 패키지 사용.
> 2.  환경 변수(`GOOGLE_API_KEY`)에서 API 키를 읽어옵니다.
> 3.  모델: "embedding-001".
> 4.  함수 정의: `export async function generateEmbedding(text: string): Promise<number[]>`
> 5.  에러 핸들링 포함.

#### Task 4.2: 데이터 주입(Ingestion) 스크립트 작성

  * 🧠 **개발자의 조언**: 작성한 Markdown 파일들을 읽어 임베딩을 생성하고, 결과를 하나의 JSON 파일로 저장합니다. DB 대신 파일을 사용하여 난이도를 낮춥니다.
  * 📄 **대상 파일**: `/scripts/ingestKnowledge.ts` (새 파일 생성 후 진행)

> 🤖 **커서 AI용 프롬프트 (파일 생성 후 전체 선택하여 Cmd+K):**
>
> RAG 데이터를 처리하는 스크립트 `/scripts/ingestKnowledge.ts`를 작성해주세요. (ts-node로 실행 가능)
>
> **요구사항:**
>
> 1.  `/knowledge_data` 폴더 내의 모든 Markdown 파일(\*.md)을 재귀적으로 읽습니다.
> 2.  **청킹(Chunking)**: 각 파일을 의미 있는 단위로 분할합니다 (약 800자 단위). `markdown-it`을 사용하여 Markdown을 순수 텍스트로 변환합니다.
> 3.  **임베딩 생성**: 각 Chunk를 `/lib/ai/embeddingUtils.ts`의 `generateEmbedding` 함수를 사용하여 벡터로 변환합니다.
> 4.  **결과 저장**: 모든 Chunk와 임베딩을 `/data/knowledgeEmbeddings.json` 파일에 저장합니다. (프로젝트 루트에 data 폴더가 없으면 생성하도록 처리)
>     형식: `[{ id: string, title: string, content: string, embedding: number[] }]`
> 5.  API 호출 시 Rate Limit을 고려하여 적절한 지연(delay, 예: 100ms)을 추가해주세요.

**(스크립트 작성 후, 터미널에서 `npx ts-node scripts/ingestKnowledge.ts`를 실행하여 JSON 파일 생성을 확인합니다.)**

#### Task 4.3: 벡터 유사도 검색 구현

📌 **Step 4-3-1: 인메모리 검색 및 유사도 계산 함수 구현**

  * 🧠 **개발자의 조언**: 사용자의 질문과 가장 유사한 문서를 JSON 파일에서 찾습니다. 이를 위해 코사인 유사도라는 수학적 계산이 필요합니다.
  * 📄 **대상 파일**: `/lib/ai/similaritySearch.ts` (새 파일 생성 후 진행)

> 🤖 **커서 AI용 프롬프트 (파일 생성 후 전체 선택하여 Cmd+K):**
>
> 인메모리 벡터 검색 함수와 코사인 유사도 계산 함수를 구현해주세요.
>
> **요구사항:**
>
> 1.  **코사인 유사도 함수 구현**:
>     함수 정의: `function cosineSimilarity(vecA: number[], vecB: number[]): number`
>     내용: 두 벡터 간의 코사인 유사도를 계산합니다. (내적 / 크기의 곱). 0으로 나누는 등의 예외 처리 포함.
>
> 2.  **인메모리 검색 함수 구현**:
>     함수명: `export async function searchKnowledgeBase(query: string)`
>     내용:
>     a. `/data/knowledgeEmbeddings.json` 파일을 읽어옵니다. (서버리스 환경을 고려하여 단순하게 매번 읽는 방식으로 구현)
>     b. 입력된 `query`를 `generateEmbedding` 함수로 벡터 변환합니다.
>     c. 쿼리 벡터와 JSON 파일의 모든 문서 벡터 간의 코사인 유사도를 계산합니다.
>     d. 유사도가 높은 상위 5개의 문서(`{title, content}`)를 반환합니다.

#### Task 4.4: 채팅 API에 RAG 통합 및 페르소나 설정

  * 🧠 **개발자의 조언**: 이제 검색된 문서를 AI에게 전달하고, 50대 고객에게 최적화된 말투와 답변 구조를 지시합니다. 보안 정책(경쟁사 언급 금지)도 여기서 설정합니다.
  * 📄 **대상 파일**: `/app/api/chat/route.ts`

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> RAG 시스템을 통합하고 AI 페르소나(System Prompt)를 설정해주세요.
>
> **요구사항:**
>
> 1.  `/lib/ai/similaritySearch.ts`의 `searchKnowledgeBase` 함수를 가져와 사용자의 최신 질문으로 검색합니다.
> 2.  AI 모델 호출 시(`streamText`의 `system` 파라미터 사용) 아래의 시스템 프롬프트를 사용하고, 검색된 문서를 `[참고 자료]` 섹션에 삽입합니다.
>
> **[시스템 프롬프트 내용 시작]**
> 당신은 크루즈 전문 가이드 AI '지니(Genie)'입니다. 50대 이상 한국인 고객을 대상으로 하며, 고객은 크루즈 여행이 처음입니다. 항상 친절하고, 정중하며, 차분한 존댓말을 사용하세요. 목표는 고객이 불안함 없이 안전하게 여행을 완주하도록 돕는 것입니다.
>
> **[응답 지침 (GPT 계획서 반영)]**
>
> 1.  **단계별 설명**: 답변은 구체적이고 단계별로(1, 2, 3...) 알기 쉽게 설명하세요.
> 2.  **쉬운 언어**: 어려운 용어 대신 쉬운 한국어를 사용하되, 필요시 병기하세요. (예: 안전 교육(Muster Drill))
> 3.  **고객 안심시키기**: "걱정하지 마세요."와 같은 표현을 사용하세요.
> 4.  **참고 자료 우선**: 반드시 아래 [참고 자료]를 최우선으로 활용하여 답변하세요.
> 5.  **말풍선 회화 제공**: 상황에 맞는 간단한 영어 회화를 1-2줄 제공하세요.
>
> **[보안 및 비즈니스 정책 - 리쿠르팅 및 이탈 방지]**
>
> 1.  절대로 다른 여행사나 경쟁사를 언급, 비교, 추천하지 마세요.
> 2.  부정적인 소통이나 고객의 불만을 조장하는 답변을 하지 마세요.
>
> **[참고 자료 시작]**
> {여기에 검색된 문서 내용들을 삽입}
> **[참고 자료 끝]**
> **[시스템 프롬프트 내용 끝]**

-----

## Phase 5: 자동화 및 비즈니스 로직 완성 (1-2주)

AI 에이전트 기능, 비즈니스 규칙(잠금, 체험판), 그리고 UX를 완성합니다.

#### Task 5.1: AI Tool Calling 구현 (난이도: ⭐⭐⭐⭐)

  * 🧠 **개발자의 조언**: AI가 단순 답변을 넘어 실제로 행동(가계부 기록 등)하게 합니다. 스키마 정의가 복잡할 수 있지만, AI의 도움을 받으면 가능합니다.
  * 📄 **대상 파일**: `/app/api/chat/route.ts`

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> Vercel AI SDK를 사용하여 Tool Calling을 구현해주세요. `streamText` 함수 내에서 도구를 정의하고 실행합니다.
>
> **요구사항:**
>
> 1.  `streamText` 호출 시 `tools` 파라미터를 사용하여 아래 도구들을 정의합니다. `zod`를 사용하여 스키마를 명확히 정의합니다.
>
> **도구 목록:**
> A. **`add_expense` (가계부 기록)**
>
>   - 설명: 사용자가 지출 내역을 말했을 때 기록 (예: "택시비 30달러 썼어")
>   - 파라미터: amount(number), currency(string), category(string), description(string)
>
> B. **`manage_checklist` (체크리스트 관리)**
>
>   - 설명: 사용자가 준비물을 챙겼거나 추가할 것을 말했을 때 관리 (예: "멀미약 챙겼어")
>   - 파라미터: action('add' | 'complete'), itemName(string)
>
> <!-- end list -->

> 2.  **`execute` 함수 구현**:
>       - 세션 정보를 활용하여 현재 `userId`와 `tripId`에 접근합니다.
>       - Prisma를 사용하여 `Expense` 또는 `ChecklistItem` 테이블에 데이터를 저장/수정합니다.
>       - 실행 결과를 자연어로 반환하여 AI가 피드백하게 합니다. (예: "네, 택시비 30달러를 기록했습니다.")

#### Task 5.2: 접근 제어 및 체험판 기능 (난이도: ⭐⭐)

📌 **Step 5-2-1: 계정 잠금 및 체험판 필드 추가**

  * 🧠 **개발자의 조언**: 여행 종료 후 접근 차단(D+2) 및 24시간 체험판 기능을 위해 데이터베이스 구조를 변경합니다.
  * 📄 **대상 파일**: `prisma/schema.prisma`

> 🤖 **커서 AI용 프롬프트 (User 모델 부분을 드래그하여 Cmd+K):**
>
> `User` 모델에 접근 제어 및 체험판 관련 필드를 추가해주세요.
>
> **추가할 필드:**
>
> 1.  `isAccessLocked`: Boolean (default: false)
> 2.  `isTrial`: Boolean (default: false)
> 3.  `trialExpiresAt`: DateTime?

*(수정 후 터미널에서 `npx prisma migrate dev`를 실행하여 DB에 반영해야 합니다.)*

📌 **Step 5-2-2: 자동 잠금 로직 구현 (D+2 정책)**

  * 📄 **대상 파일**: 스케줄러 파일 (예: `/app/api/cron/trip-status-updater/route.ts`)

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> 스케줄러에 사용자 계정 자동 잠금 로직을 추가해주세요.
>
> **비즈니스 규칙**: 매일 실행 시, 다음 조건을 만족하는 사용자를 찾습니다.
>
> 1.  모든 여행이 'Completed' 상태이다.
> 2.  마지막 여행 종료일로부터 2일이 지났다.
> 3.  예정된 다음 여행(Upcoming)이 없다.
>
> 조건 만족 시, 해당 사용자의 `isAccessLocked`를 true로 설정합니다.

📌 **Step 5-2-3: 접근 제어 시행 (미들웨어)**

  * 📄 **대상 파일**: `middleware.ts`

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> 미들웨어를 수정하여 계정 잠금 및 체험판 만료 정책을 시행해주세요.
>
> **요구사항:**
>
> 1.  세션에서 사용자 정보를 확인합니다.
> 2.  `isAccessLocked`가 true이면, 세션을 파기하고 `/access-locked` 페이지로 리디렉션합니다.
> 3.  `isTrial`이 true이고 현재 시간이 `trialExpiresAt`을 지났으면, 세션을 파기하고 `/trial-expired` 페이지로 리디렉션합니다.

#### Task 5.3: 50대 맞춤형 UX 구현 (퀵 카드) (난이도: ⭐⭐)

  * 🧠 **개발자의 조언**: GPT 계획서에서 제안된 'Top 4 Quick Cards'를 홈 화면에 구현하여 메뉴 이동 없이 핵심 기능에 접근하게 합니다.
  * 📄 **대상 파일**: 홈 화면 (예: `/app/home/page.tsx` 또는 `/app/page.tsx`)

> 🤖 **커서 AI용 프롬프트 (파일 내용을 드래그하여 Cmd+K):**
>
> 홈 화면 상단에 50대 사용자를 위한 "Top 4 Quick Cards"를 배치해주세요. Tailwind CSS를 사용하며, 2x2 그리드 형태입니다.
>
> **카드 구성 (GPT 계획서 기반):**
>
> 1.  오늘 할 일 (여행 단계별 핵심 절차 링크/요약)
> 2.  필수 준비물/반입 금지 확인 (체크리스트 링크)
> 3.  승선권(E-Ticket)/러기지 태그 보기 (링크)
> 4.  말풍선 회화 (상황별 회화 도우미 링크 또는 모달)
>
> **디자인**: 각 카드는 크고 명확한 아이콘과 큰 글씨(최소 lg 이상)로 구성됩니다. 탭하기 쉬워야 합니다.

-----

## 결론 및 다음 단계

대표님, 이 V3.0 계획서는 기술적 난이도를 현실적으로 낮추면서(인메모리 RAG 도입) '지니'의 핵심 비전을 달성하기 위한 구체적이고 실현 가능한 방안입니다.

**가장 중요한 것은 끈기입니다.** 코딩 초보자에게 이 프로젝트는 분명 도전적이지만, 이 초미세 작업 지시서를 따라 하나씩 해결해나가면 반드시 완성할 수 있습니다. 에러가 발생하면 당황하지 말고, 에러 메시지를 그대로 복사하여 AI에게 도움을 요청하세요.

**지금 바로 Phase 1, Task 1.1부터 시작하세요.** 동시에 \*\*Phase 3 (콘텐츠 작성)\*\*을 매일 꾸준히 진행하는 것이 프로젝트 성공의 열쇠입니다. 대표님의 성공적인 프로젝트 완성을 응원합니다\!