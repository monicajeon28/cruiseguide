## 크루즈 가이드 AI '지니(Genie)' 프로젝트 최종 완성 실행 계획서

대표님, 공유해주신 프로젝트 현황 보고서와 크루즈 여행 사업에 대한 깊은 고민, 그리고 비전을 진심으로 이해했습니다. 50대 이상 고객이 낯선 크루즈 여행 앞에서 느끼는 두려움을 해소하고, 예약부터 귀가까지 완벽한 동반자가 되어주는 AI 서비스를 만들겠다는 목표는 매우 훌륭하며, 현재 한국 시장에 꼭 필요한 서비스입니다.

코딩 초보자로서의 어려움, 경험 부족, 그리고 AI 개발 비용(토큰)에 대한 부담감까지 모두 공감합니다. 현재 프로젝트는 85%의 훌륭한 인프라를 갖추고 있지만, 고객의 실질적인 불안을 해소해 줄 \*\*'전문 지식(Knowledge)'\*\*과 AI의 \*\*'실행 능력(Agency)'\*\*이 부족한 상태입니다.

이 계획서는 대표님께서 커서(Cursor)와 Claude 3.5 Sonnet을 활용하여 **비용 효율적으로 프로젝트를 완성**할 수 있도록 돕는 실전 가이드입니다. 기존의 복잡하고 토큰 소모가 많았던 작업자 방식을 버리고, 대표님이 직접 AI에게 지시할 수 있는 **아주 구체적이고 세분화된 마이크로 작업 지시서**를 제공하겠습니다.

-----

### 0\. 프로젝트 핵심 원칙 및 개발 전략

**비전 재확인**: "가장 쉽고, 가장 안전하며, 가장 똑똑한 크루즈 여행 동반자"

**50대 이상 고객을 위한 핵심 원칙**:

1.  **극도의 단순성**: 복잡한 메뉴는 숨기고, 모든 것은 대화창('지니')을 통해 해결합니다.
2.  **선제적 안심 제공**: 고객이 묻기 전에, 필요한 정보를 적시에 제공합니다.
3.  **전문성과 신뢰**: 부족한 한국어 크루즈 정보를 완벽하게 보완합니다. (RAG의 중요성)
4.  **안전 최우선**: 특히 기항지에서 배로 돌아오는 안전을 최우선으로 보장합니다.

**커서(Cursor) 활용 및 토큰 절약 전략**:

Claude 3.5 Sonnet 환경에서 토큰을 아끼는 핵심은 AI가 처리해야 할 정보의 양을 최소화하는 것입니다.

1.  **마이크로 태스크(Micro-Task) 방식**: 작업을 아주 작게 쪼개어 한 번에 하나의 명확한 작업만 지시합니다.
      * *(나쁜 예)*: "채팅 기록 저장 기능을 만들어줘" (X)
      * *(좋은 예)*: "`/app/api/chat/route.ts` 파일에서 AI 응답 완료 후, `ChatHistory` 모델을 사용해 응답 내용을 DB에 저장하는 코드를 추가해줘." (O)
2.  **1파일 1작업 원칙**: 한 번의 요청으로 하나의 파일만 수정하거나 생성하도록 합니다.
3.  **명확한 컨텍스트 제공**: 작업 대상 파일을 명시하고(`@파일명`), 필요한 정보만 제공합니다. 불필요하게 전체 코드베이스를 참조하지 않습니다.
4.  **Edit 기능 활용 (Cmd+K)**: 커서에서 수정이 필요한 코드 블록을 드래그한 후 `Cmd+K`(Edit)를 눌러 수정 지시를 내리면, 토큰 사용량을 획기적으로 줄일 수 있습니다.

-----

### 1\. 개발 로드맵 재설계

기존의 미완료 작업과 새로운 우선순위를 반영하여 로드맵을 5단계로 재구성했습니다.

  * **Phase 1: 긴급 수정 및 기반 안정화** (1주)
  * **Phase 2: 핵심 안전 기능 완성** (1주)
  * **Phase 3: 지식 엔진 구축 (RAG) - ⭐프로젝트의 심장⭐** (2-3주)
  * **Phase 4: AI 에이전트화 (Tool Calling)** (1주)
  * **Phase 5: 비즈니스 로직 및 고도화** (1주)

-----

### Phase 1: 긴급 수정 및 기반 안정화 (1주)

이 단계에서는 보고서에서 지적된 심각한 문제들을 우선 해결하여 시스템의 신뢰도를 높입니다.

#### Task 1.1: 메시지 히스토리 유실 문제 해결 (Critical)

**목표**: 새로고침해도 대화 내용이 유지되도록 합니다.

📌 **Step 1-1-1: 대화 기록 로드 API 구현**

  * **대상 파일**: `/app/api/chat/history/route.ts` (신규 생성 권장)

> **Cursor AI용 프롬프트:**
> 새로운 API 엔드포인트 `/app/api/chat/history/route.ts`를 생성해주세요. 사용자의 이전 채팅 기록을 로드하는 기능을 구현합니다.
>
> **요구사항:**
>
> 1.  Next.js API Route (App Router 방식)로 `GET` 요청을 처리합니다.
> 2.  현재 로그인한 사용자의 `userId`와 현재 활성화된 `tripId`를 세션에서 확인합니다. (인증 체크 필수)
> 3.  Prisma를 사용하여 `ChatHistory` 테이블에서 해당 기록을 조회합니다.
> 4.  최근 50개의 메시지만 조회하고, 생성 시간(`createdAt`) 기준으로 오름차순(오래된 것부터) 정렬합니다.
> 5.  결과를 Vercel AI SDK 호환 포맷(`{id: string, role: 'user' | 'assistant', content: string}[]`)으로 변환하여 반환합니다.

📌 **Step 1-1-2: 프론트엔드 대화 기록 로드 적용**

  * **대상 파일**: 채팅 UI 컴포넌트 (예: `/app/chat/page.tsx` 또는 `ChatClientShell.tsx`)

> **Cursor AI용 프롬프트:**
> 채팅 화면 컴포넌트(`[여기에 파일 경로 입력]`)를 수정하여 페이지 로드 시 이전 대화 기록을 불러오려고 합니다.
>
> **요구사항:**
>
> 1.  컴포넌트가 마운트될 때 `/api/chat/history` API를 호출합니다.
> 2.  Vercel AI SDK의 `useChat` 훅을 사용 중이라면, API 호출 결과를 `initialMessages` 옵션에 설정하는 방법을 사용해주세요.
> 3.  데이터를 불러오는 동안 로딩 상태를 표시해주세요.
>
> (현재 채팅 UI 컴포넌트 코드를 여기에 붙여넣으세요.)

📌 **Step 1-1-3: 백엔드 메시지 저장 로직 구현**

  * **대상 파일**: `/app/api/chat/route.ts`

> **Cursor AI용 프롬프트:**
> `/app/api/chat/route.ts` 파일을 수정하여 채팅 기록을 데이터베이스에 저장하려고 합니다.
>
> **요구사항:**
>
> 1.  사용자의 메시지(role: user)와 AI의 응답(role: assistant)을 `ChatHistory`에 저장합니다.
> 2.  Vercel AI SDK의 `streamText`를 사용 중이라면, 스트리밍이 완료된 후 최종 응답을 저장해야 합니다. `onCompletion` 콜백을 사용하여 구현해주세요.
> 3.  저장 시 현재 사용자의 `userId`와 `tripId`를 함께 기록합니다.
>
> (현재 `/app/api/chat/route.ts` 파일의 코드를 여기에 붙여넣으세요.)

#### Task 1.2: 데이터 마이그레이션 (LocalStorage → DB)

**목표**: 가계부와 체크리스트 데이터를 DB로 옮겨 AI가 접근 가능하게 합니다. (Tool Calling 선행 조건)

📌 **Step 1-2-1: 가계부(Wallet) 페이지 데이터 소스 변경**

  * **대상 파일**: `/app/wallet/page.tsx`

> **Cursor AI용 프롬프트:**
> 현재 `/app/wallet/page.tsx`는 LocalStorage를 사용하고 있습니다. 이를 백엔드 API(`/api/expenses`)를 사용하도록 전면 수정해주세요.
>
> **요구사항:**
>
> 1.  모든 LocalStorage 접근 코드를 제거합니다.
> 2.  **조회**: 페이지 로드 시 `GET /api/expenses`를 호출합니다.
> 3.  **추가/수정/삭제**: `POST/PUT/DELETE` 요청을 사용하여 API를 호출합니다.
> 4.  API 호출 상태(로딩 중, 성공, 실패)에 따른 UI 피드백을 구현합니다. (간단한 `useState`와 `useEffect` 사용 권장)
>
> (현재 `/app/wallet/page.tsx` 코드를 여기에 붙여넣으세요.)

📌 **Step 1-2-2: 체크리스트 페이지 데이터 소스 변경**

  * **(Step 1-2-1과 동일한 방식으로 `/app/checklist/page.tsx` 파일에 대해 작업 지시를 내립니다.)**

#### Task 1.3: 스트리밍 응답 구현 (UX 개선)

**목표**: AI 응답을 실시간으로 표시하여 대기 시간을 줄입니다.

📌 **Step 1-3-1: 백엔드 스트리밍 응답 적용**

  * **대상 파일**: `/app/api/chat/route.ts`

> **Cursor AI용 프롬프트:**
> `/app/api/chat/route.ts`의 AI 응답 방식을 스트리밍으로 전환하려고 합니다. Vercel AI SDK와 `@ai-sdk/google`을 사용합니다.
>
> **요구사항:**
>
> 1.  현재 `generateText`를 사용하고 있다면, 이를 `streamText`로 변경합니다.
> 2.  모델은 'gemini-2.5-flash'를 유지합니다.
> 3.  응답을 `StreamingTextResponse`로 반환하도록 수정합니다.
> 4.  **중요**: Task 1.1에서 구현한 메시지 저장 로직이 `streamText`의 `onCompletion` 콜백 내에서 정상적으로 동작하는지 확인하고 필요시 수정해주세요.
>
> (현재 `/app/api/chat/route.ts` 코드를 여기에 붙여넣으세요.)

-----

### Phase 2: 핵심 안전 기능 완성 (1주)

고객의 가장 큰 두려움인 '기항지에서 배를 놓치는 것'을 방지하는 기능을 완성합니다.

#### Task 2.1: "배로 돌아가기(Return to Ship)" 기능 구현 (Critical)

**목표**: 기항지 관광 중 화면 상단에 항구까지의 경로와 남은 시간을 상시 표시합니다.

📌 **Step 2-1-1: ReturnToShipBanner 컴포넌트 생성 및 기본 UI**

  * **대상 파일**: `/app/chat/components/ReturnToShipBanner.tsx` (신규 생성)

> **Cursor AI용 프롬프트:**
> 새로운 컴포넌트 `/app/chat/components/ReturnToShipBanner.tsx`를 생성해주세요. 기항지 관광 중 안전한 귀선을 돕는 배너입니다.
>
> **Props 정의:**
>
>   * `departureTime`: 출항 시간 (ISO Date string)
>   * `allAboardTime`: 승선 마감 시간 (ISO Date string, 보통 출항 30분 전)
>   * `portLocation`: 항구 위치 `{lat: number, lng: number, name: string}` (⚠️ Itinerary 데이터에 이 정보가 필요함)
>
> **요구사항:**
>
> 1.  **카운트다운 타이머**: `allAboardTime`까지 남은 시간을 실시간으로 표시합니다. (예: "승선 마감까지 1시간 15분 남음")
> 2.  **경고**: 남은 시간이 1시간 미만이면 배너 배경을 빨간색으로 강조합니다.
> 3.  **UI 디자인**: Tailwind CSS를 사용하여 매우 눈에 잘 띄게 만듭니다. 50대 이상 사용자를 위해 폰트 크기를 크게 설정합니다. "구글 지도로 길찾기" 버튼을 포함합니다.

📌 **Step 2-1-2: GPS 위치 실시간 추적 및 Google Maps 연동**

  * **대상 파일**: `/app/chat/components/ReturnToShipBanner.tsx`

> **Cursor AI용 프롬프트:**
> `ReturnToShipBanner.tsx`에 GPS 위치 실시간 추적 및 Google Maps 연동 기능을 추가해주세요.
>
> **요구사항:**
>
> 1.  **GPS 실시간 추적**: 브라우저의 Geolocation API (`navigator.geolocation.watchPosition`)를 사용하여 현재 위치(위도, 경도)를 실시간으로 추적합니다.
> 2.  **권한 요청 및 에러 처리**: 위치 정보 접근 권한을 요청하고, GPS 신호를 찾을 수 없거나 권한이 거부된 경우 안내 메시지를 표시합니다.
> 3.  **Google Maps 링크**: "구글 지도로 길찾기" 버튼 클릭 시, 다음 형식의 URL을 새 탭으로 엽니다. (대중교통 우선)
>     `https://www.google.com/maps/dir/?api=1&origin={현재위치Lat},{현재위치Lng}&destination={항구Lat},{항구Lng}&travelmode=transit`
>
> (Step 2-1-1에서 생성된 `ReturnToShipBanner.tsx` 코드를 붙여넣으세요.)

📌 **Step 2-1-3: 배너 표시 조건 구현**

  * **대상 파일**: 채팅 메인 화면 (예: `/app/chat/page.tsx` 또는 `ChatInteractiveUI.tsx`)

> **Cursor AI용 프롬프트:**
> 채팅 화면 컴포넌트(`[여기에 파일 경로 입력]`)에 `ReturnToShipBanner`를 통합하고 조건부로 렌더링하려고 합니다.
>
> **요구사항:**
>
> 1.  현재 여행 데이터(Trip, Itinerary)를 가져옵니다.
> 2.  **조건 확인**:
>       * 여행 상태가 `InProgress`인지 확인합니다.
>       * 오늘의 일정이 '기항지(Port)'이고, 현재 시간이 도착 시간 이후이며 출항 시간 이전인지 확인합니다.
> 3.  위 조건이 만족할 경우에만 `ReturnToShipBanner`를 화면 최상단에 고정하여 렌더링하고 필요한 Props를 전달합니다.
>
> (채팅 화면 컴포넌트 코드를 붙여넣으세요.)

-----

### Phase 3: 지식 엔진 구축 (RAG) - ⭐프로젝트의 심장⭐ (2-3주)

이 단계가 프로젝트의 성패를 좌우합니다. 대표님의 노력이 가장 많이 필요한 단계입니다.

#### Task 3.1: 크루즈 지식 베이스(Knowledge Base) 콘텐츠 생성 (🌟매우 중요🌟)

대표님께서 50대 이상 고객의 입장에서 궁금해할 모든 내용을 정리해야 합니다. Q\&A 형식이나 단계별 설명 형식으로 문서를 작성해주세요. (Markdown 파일 권장)

**필수 지식 카테고리 상세 (Knowledge Map):**

**1. 여행 준비 (Pre-Cruise)**

  * **준비물 (Packing List)**
      * 필수 서류: 여권(유효기간 6개월 이상), 비자(ESTA, 중국 비자 등), E-Ticket 출력물, 러기지 태그 출력물.
      * 의류: 동반자별(아이 동반, 부모님 동반), 정찬용(Formal Night) 복장 가이드(한복 추천 포함), 평상복, 수영복.
      * 상비약: 멀미약(필수), 소화제, 진통제, 지병 약(영문 처방전 지참).
  * **반입 금지 물품 (중요\!)**: 다리미, 멀티탭(규정 확인 필요), 전열기구, 주류(선사별 규정).
  * **환전 및 결제**: 선내 통화(USD/EUR), 선상 카드(SeaPass) 등록 방법(신용카드 연결), 팁(Gratuity) 문화 설명 및 지불 방식.
  * **통신**: 선내 Wi-Fi 패키지 설명(비싸고 느림), 해외 로밍 vs 유심 vs eSIM 비교.

**2. 출국 및 터미널 이동**

  * **국내/해외 터미널**: 주요 터미널(인천, 부산, 싱가포르 등) 가는 방법 (대중교통, 자가용, 주차장 정보 및 요금).
  * **도착 시간**: 권장 도착 시간 (출항 3\~4시간 전).

**3. 승선 절차 (Embarkation) - 단계별 상세 가이드**

  * **Step 1: 짐 부치기**: 터미널 도착 직후 포터(Porter)에게 짐 전달. 러기지 태그 부착 확인. (팁 주기 문화 설명)
  * **Step 2: 체크인 카운터**: 필요 서류 제시, 사진 촬영.
  * **Step 3: 승선 카드 발급**: 승선 카드의 기능 설명 (객실 키, 신분증, 결제 수단).
  * **Step 4: 보안 검색 및 승선**.
  * **Step 5: 승선 후**: 객실 찾기, 짐 도착 확인(늦어질 수 있음 안내).
  * **Step 6: 안전 교육 (Muster Drill)**: 필수 참석 안내.

**4. 선내 생활 (Onboard Life)**

  * **식사**: 정찬 식당(MDR) 이용 시간, 드레스 코드 확인법, 메뉴 보는 법, 주문 방법(영어로 주문하기 팁). 뷔페 이용 팁.
  * **시설 이용**: 수영장, 헬스장, 스파 등 위치 및 이용 시간.
  * **프로그램**: 선상 신문(Daily Planner) 보는 법 및 활용 팁. 주요 공연 예약 방법.

**5. 기항지 관광 (Ports of Call)**

  * **하선 절차**: 하선 시 준비물(승선 카드, 여권 사본).
  * **자유여행 vs 선사 투어**: 장단점 비교 및 선택 가이드.
  * **귀선 시간 (매우 중요\!)**: **재승선 마감 시간(All Aboard Time) 엄수 강조 (늦으면 배는 기다려주지 않음).**

**6. 하선 절차 (Disembarkation)**

  * **하선 전날**: 선내 결제 정산서 확인 방법. 짐 싸기 및 객실 앞에 내놓기(하선용 태그 부착).
  * **하선 당일**: 아침 식사, 지정된 장소에서 대기, 하선 순서 안내.

**(대표님께서는 이 카테고리들을 바탕으로 실제 콘텐츠를 작성하셔야 합니다. 예: `knowledge_data/embarkation_guide.md`)**

-----

#### Task 3.2: RAG 기술 구현 (지식 주입 파이프라인)

작성된 문서를 AI가 활용할 수 있도록 기술적으로 구현합니다. (PostgreSQL 및 `pgvector` 사용 가정)

📌 **Step 3-2-1: 데이터베이스 및 스키마 설정 (pgvector 활성화)**

  * **대상 파일**: `prisma/schema.prisma`

> **Cursor AI용 프롬프트:**
> RAG 구현을 위해 Prisma 스키마를 업데이트하려고 합니다. PostgreSQL의 `pgvector` 확장을 사용할 예정입니다.
>
> **요구사항:**
>
> 1.  Prisma가 `pgvector` 확장을 인식하도록 설정합니다. (예: `extensions = [pgvector(map: "vector")]`를 `generator client` 블록에 추가)
> 2.  `KnowledgeBase` 모델에 임베딩 벡터를 저장할 `embedding` 필드를 추가합니다. 타입은 `Unsupported("vector(768)")`로 설정합니다. (Google Embedding 모델 기준)
> 3.  `KnowledgeBase` 모델에 원본 텍스트 `content`, `title`, `category` 필드가 있는지 확인하고 필요시 보강해주세요.
>
> (현재 `prisma/schema.prisma` 파일을 첨부하세요.)

*(이후 `npx prisma migrate dev`를 실행해야 합니다.)*

📌 **Step 3-2-2: 데이터 주입(Ingestion) 및 임베딩 생성 스크립트 작성**

  * **대상 파일**: `/scripts/ingestAndEmbedKnowledge.ts` (신규 생성)

> **Cursor AI용 프롬프트:**
> RAG 지식 데이터를 데이터베이스에 주입하고 임베딩을 생성하는 스크립트 `/scripts/ingestAndEmbedKnowledge.ts`를 작성해주세요.
>
> **환경**: TypeScript (ts-node로 실행 가능)
> **사용 기술**: Prisma, Google Generative AI SDK (`@google/generative-ai`)
>
> **요구사항:**
>
> 1.  `/knowledge_data` 폴더(가정)에 있는 Markdown 파일들을 읽습니다.
> 2.  **청킹(Chunking)**: 각 파일을 의미 있는 단위(예: 1000자 단위 또는 헤더 기준)로 분할합니다.
> 3.  **임베딩 생성**: 각 Chunk의 텍스트를 Google Embedding API(모델: `embedding-001`)를 사용하여 벡터로 변환합니다.
> 4.  **DB 저장**: Prisma를 사용하여 `KnowledgeBase` 테이블에 `content`와 `embedding`을 저장합니다.
> 5.  **pgvector 저장**: 벡터를 저장할 때는 Prisma의 Raw Query를 사용해야 합니다.
>     (예시 SQL: `INSERT INTO "KnowledgeBase" (content, embedding) VALUES ($1, $2::vector)`)

*(스크립트 작성 후, 대표님이 작성한 Markdown 파일을 `/knowledge_data` 폴더에 넣고 스크립트를 실행합니다.)*

#### Task 3.3: RAG 기반 채팅 API 구현 (지식 활용)

📌 **Step 3-3-1: 벡터 유사도 검색(Semantic Search) 기능 구현**

  * **대상 파일**: `/lib/ragSearch.ts` (신규 생성)

> **Cursor AI용 프롬프트:**
> 사용자의 질문과 유사한 지식 문서를 검색하는 함수를 구현해주세요. `/lib/ragSearch.ts` 파일을 생성합니다.
>
> **함수명**: `searchKnowledgeBase(query: string)`
>
> **요구사항:**
>
> 1.  입력된 `query`를 Google Embedding API를 사용해 벡터로 변환합니다.
> 2.  Prisma Raw Query를 사용하여 `KnowledgeBase` 테이블에서 유사한 문서를 검색합니다.
> 3.  **검색 알고리즘**: 코사인 유사도(Cosine Similarity)를 사용합니다. pgvector 문법: `1 - ("embedding" <=> $1::vector) AS similarity`
> 4.  유사도가 높은 상위 5개의 문서(`content`, `title`)를 반환합니다.

📌 **Step 3-3-2: 채팅 API에 RAG 로직 통합 및 페르소나 설정**

  * **대상 파일**: `/app/api/chat/route.ts`

> **Cursor AI용 프롬프트:**
> `/app/api/chat/route.ts`를 수정하여 RAG 시스템을 통합하고 AI 페르소나를 설정해주세요.
>
> **요구사항:**
>
> 1.  사용자의 최신 질문을 `searchKnowledgeBase` 함수로 검색합니다.
> 2.  **시스템 프롬프트 수정**: AI 모델 호출 시 사용할 시스템 프롬프트를 아래 내용으로 수정하고, 검색된 문서를 `[참고 자료]` 섹션에 삽입합니다.
>
> **시스템 프롬프트 (페르소나 및 지침):**
>
> ```
> 당신은 크루즈 전문 가이드 AI '지니(Genie)'입니다. 50대 이상 한국인 고객을 대상으로 합니다. 항상 친절하고, 정중하며, 차분한 존댓말을 사용하세요. 당신의 목표는 고객이 불안함 없이 안전하고 즐겁게 크루즈 여행을 완주하도록 돕는 것입니다.
> ```

> [응답 지침]
>
> 1.  답변은 항상 구체적이고 단계별로 알기 쉽게 설명하세요.
> 2.  어려운 전문 용어(예: Muster Drill) 대신 쉬운 한국어(예: 안전 교육)를 사용하되, 필요한 경우 용어를 병기하세요.
> 3.  고객의 불안감을 이해하고 안심시키는 표현을 사용하세요. (예: "걱정하지 마세요, 제가 차근차근 알려드릴게요.")
> 4.  반드시 아래 제공된 [참고 자료]를 최우선으로 활용하여 답변하세요.

> [보안 정책]
>
> 1.  절대로 다른 여행사나 경쟁사를 언급, 비교, 추천하지 마세요. (리쿠르팅 및 이탈 방지)
> 2.  회사 내부의 부정적인 소통이나 고객의 불만을 조장하는 답변을 하지 마세요.

> [참고 자료 시작]
> {검색된 문서 내용들을 여기에 삽입}
> [참고 자료 끝]
>
> ```
> 
> (현재 `/app/api/chat/route.ts` 코드를 여기에 붙여넣으세요.)
> ```

-----

### Phase 4: AI 에이전트화 - Tool Calling 구현 (1주)

AI가 정보를 제공하는 것을 넘어 사용자를 위해 행동하게 합니다. (예: "택시비 30달러 썼다고 기록해줘")

#### Task 4.1: AI 도구 정의 (Tool Specification)

**목표**: AI가 사용할 수 있는 도구(가계부 기록, 체크리스트 관리)를 정의합니다.

📌 **Step 4-1-1: AI 도구 정의 파일 생성**

  * **대상 파일**: `/lib/ai/tools.ts` (신규 생성)

> **Cursor AI용 프롬프트:**
> AI가 사용할 수 있는 도구들을 정의하는 `/lib/ai/tools.ts` 파일을 생성해주세요. Vercel AI SDK의 `tool` 함수와 `zod`를 사용하여 스키마를 정의합니다.
>
> **정의할 도구 목록:**
>
> 1.  **`add_expense` (가계부 기록)**
>
>       * 파라미터: `amount` (number), `currency` (string, 예: USD, KRW), `category` (string, 예: 교통, 식비), `description` (string)
>
> 2.  **`add_checklist_item` (체크리스트 추가)**
>
>       * 파라미터: `itemName` (string)
>
> 3.  **`complete_checklist_item` (체크리스트 완료)**
>
>       * 파라미터: `itemName` (string, AI가 사용자의 말에서 유추)
>
> 각 도구의 정의 코드를 작성해주세요. `execute` 함수는 아직 비워둡니다.

#### Task 4.2: 도구 실행 로직 구현 및 API 통합

**목표**: AI가 도구 사용을 요청하면 실제로 실행하는 로직을 구현합니다.

📌 **Step 4-2-1: 도구 실행 로직 구현 및 통합**

  * **대상 파일**: `/app/api/chat/route.ts`

> **Cursor AI용 프롬프트:**
> `/app/api/chat/route.ts`를 수정하여 Tool Calling을 활성화하고 도구 실행 로직을 구현해주세요.
>
> **요구사항:**
>
> 1.  `/lib/ai/tools.ts`에서 정의한 도구들을 가져옵니다.
> 2.  `streamText` 함수 호출 시 `tools` 파라미터를 전달합니다.
> 3.  각 도구의 `execute` 함수 내부에 실제 실행 로직을 구현합니다. (Vercel AI SDK는 `streamText` 호출 시 `tools` 객체 내에서 `execute`를 정의하는 것을 선호합니다.)
>       * `execute` 함수는 현재 사용자의 `userId`와 `tripId`에 접근할 수 있어야 합니다.
>       * **`add_expense` 실행**: Prisma를 사용하여 `Expense` 테이블에 데이터를 저장합니다.
>       * **체크리스트 도구 실행**: Prisma를 사용하여 `ChecklistItem` 테이블을 조작합니다.
> 4.  도구 실행 결과를 반환하여 AI가 자연스러운 피드백을 제공하도록 합니다. (예: "네, 택시비 30달러를 기록했습니다.")
>
> (현재 `/app/api/chat/route.ts` 코드를 붙여넣고, Step 4-1-1의 도구 정의 코드를 참고 자료로 제공하세요.)

-----

### Phase 5: 비즈니스 로직 및 고도화 (1주)

서비스의 지속 가능성과 비즈니스 목표 달성을 위한 기능들을 구현합니다.

#### Task 5.1: 접근 제어 및 계정 잠금 정책 구현

**목표**: 여행 종료 D+2일 후 자동으로 로그인을 차단하여 서비스 독점성을 유지하고 재예약을 유도합니다.

📌 **Step 5-1-1: 계정 자동 잠금 로직 강화**

  * **대상 파일**: `prisma/schema.prisma`, 스케줄러 (예: `/app/api/cron/trip-status-updater/route.ts`)

> **Cursor AI용 프롬프트:**
> 여행 종료 후 사용자 접근을 자동으로 차단하는 로직을 구현하려고 합니다.
>
> **비즈니스 규칙**: 마지막 여행 종료일로부터 2일이 지나고, 예정된 다음 여행이 없으면 접근을 차단합니다.
>
> **구현 방안:**
>
> 1.  **Prisma 스키마 수정 (`prisma/schema.prisma`)**: `User` 모델에 `isAccessLocked` (Boolean, default: false) 필드를 추가합니다.
> 2.  **스케줄러 수정 (`/app/api/cron/trip-status-updater/route.ts`)**:
>       * 매일 자정 실행 시, 모든 여행이 `Completed` 상태인 사용자를 찾습니다.
>       * 마지막 여행 종료일로부터 2일이 지났는지 확인합니다.
>       * 조건에 맞으면 `isAccessLocked`를 true로 설정합니다.
>
> 위 두 파일에 대한 수정 코드를 제시해주세요.

📌 **Step 5-1-2: 접근 제어 시행 (미들웨어 및 로그인)**

  * **대상 파일**: `middleware.ts`, `/app/api/auth/login/route.ts`

> **Cursor AI용 프롬프트:**
> `middleware.ts`와 `/app/api/auth/login/route.ts`를 수정하여 계정 잠금을 시행해주세요.
>
> **요구사항:**
>
> 1.  **로그인 API**: 로그인 시도 시, `isAccessLocked`가 true이면 로그인을 거부하고, "이용 기간이 만료되었습니다. 다음 여행 예약 시 자동으로 활성화됩니다."라는 에러 메시지를 반환합니다.
> 2.  **미들웨어**: 보호된 경로 접근 시, 세션의 `isAccessLocked` 상태를 확인합니다. 잠겨 있다면, 세션을 파기하고 접근 거부 페이지(`/access-locked`)로 리디렉션합니다.
>
> 위 두 파일에 대한 수정 코드를 제시해주세요. (각 파일의 현재 코드를 붙여넣으세요.)

#### Task 5.2: 24시간 체험판 (Trial Version) 기능 구현

**목표**: 마케팅 및 경쟁사 방지를 위해 24시간 체험 기능을 제공합니다.

📌 **Step 5-2-1: 체험판 사용자 상태 정의 및 생성 API**

  * **대상 파일**: `prisma/schema.prisma`, `/api/admin/create-trial-user/route.ts` (신규 생성)

> **Cursor AI용 프롬프트:**
> 24시간 체험판 기능을 구현하려고 합니다.
>
> **1. Prisma 스키마 수정 (`prisma/schema.prisma`):**
>
>   * `User` 모델에 `isTrial` (Boolean, default: false) 및 `trialExpiresAt` (DateTime) 필드를 추가합니다.
>
> **2. 체험판 생성 API 구현 (`/api/admin/create-trial-user/route.ts`):**
>
>   * 관리자 권한으로 호출할 수 있는 API를 만듭니다. (관리자가 통제 하에 체험판 제공)
>   * 임시 사용자 계정을 생성하고, `isTrial`을 true로, `trialExpiresAt`을 현재로부터 24시간 뒤로 설정합니다.
>   * 체험판 사용자가 경험할 수 있도록 가상의 크루즈 여행 데이터(`Trip`)를 생성하여 할당합니다.
>   * 생성된 임시 계정 정보(ID/PW)를 반환합니다.
>
> 위 두 가지 작업에 대한 코드를 제시해주세요.

📌 **Step 5-2-2: 체험판 만료 처리**

  * **대상 파일**: `middleware.ts`

> **Cursor AI용 프롬프트:**
> `middleware.ts`를 수정하여 체험판 사용자의 접근을 제어해주세요.
>
> **요구사항:**
>
> 1.  사용자가 `isTrial`이 true인지 확인합니다.
> 2.  현재 시간이 `trialExpiresAt`을 지났는지 확인합니다.
> 3.  만료되었다면, 세션을 파기하고 '체험 기간 만료' 페이지(`/trial-expired`)로 리디렉션합니다.
>
> (현재 `middleware.ts` 코드를 붙여넣으세요.)

#### Task 5.3: 고객 유형별 개인화 준비 (데이터 수집)

**목표**: 동반자 유형(가족, 노인 동반, 커플 등)에 따른 맞춤형 서비스를 제공하기 위해 온보딩 시 정보를 수집합니다.

📌 **Step 5-3-1: 온보딩 프로세스에 고객 유형 선택 추가**

  * **대상 파일**: 온보딩 페이지 (예: `/app/onboarding/page.tsx`), `prisma/schema.prisma`

> **Cursor AI용 프롬프트:**
> 온보딩 프로세스에 동반자 유형을 선택하는 단계를 추가하려고 합니다.
>
> **요구사항:**
>
> 1.  **Prisma 스키마 수정**: `User` 모델에 `companionType` 필드를 추가합니다. (Enum: FAMILY\_KIDS, FAMILY\_SENIORS, COUPLE, FRIENDS, SOLO)
> 2.  **온보딩 UI 수정**: 기존 온보딩 과정에 동반자 유형을 선택하는 화면을 추가합니다.
> 3.  **선택지**: "어린 자녀 동반", "부모님 동반(60대 이상)", "연인/부부", "친구", "혼자"
> 4.  **UI 디자인**: 50대 이상 사용자가 쉽게 선택할 수 있도록 버튼을 크고 명확하게 디자인합니다.
> 5.  **데이터 저장**: 선택된 값을 사용자 프로필 업데이트 API를 호출하여 저장합니다.
>
> 위 작업에 대한 코드를 제시해주세요.

-----

### 결론 및 다음 단계

대표님, 이 상세 실행 계획서는 현재 '지니' 프로젝트의 강력한 인프라를 기반으로, 고객에게 실질적인 가치를 제공할 핵심 기능들을 완성하기 위한 구체적인 로드맵입니다.

\*\*성공의 열쇠는 Phase 3 (지식 주입)\*\*에 있습니다. 기술적인 구현은 이 가이드라인을 따라 커서 AI와 함께 해결할 수 있지만, 고객의 불안을 해소할 전문적인 크루즈 지식과 노하우는 대표님께서 직접 채워주셔야 합니다. 이 부분이 완성되어야만 환불율 0%라는 목표를 달성하고, 진정한 AI 동반자 서비스가 될 수 있습니다.

**지금 바로 시작할 작업:**

1.  \*\*Phase 1, Task 1.1 (메시지 히스토리 저장)\*\*의 첫 번째 스텝부터 시작하세요. 제시된 프롬프트를 복사하여 Cursor AI에게 요청하시면 됩니다.

작게 쪼개진 마이크로 태스크를 하나씩 완료해나가다 보면, 어느새 완벽한 AI 크루즈 가이드 '지니'가 완성되어 있을 것입니다. 대표님의 비전이 실현되기를 진심으로 응원합니다.