import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs';
import path from 'path';
import { verifyJwt } from '@/lib/auth';
import { withOptionalAuth } from '@/lib/authMiddleware';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || 'AIzaSyCzHskiUWDn3CgCEaVGPh-ymEOm4rcKT4I');

export const POST = withOptionalAuth(async (request: NextRequest, userId?: string) => {
  try {
    const { message } = await request.json();

    if (!message) {
      return new NextResponse(JSON.stringify({ error: 'ë©”ì‹œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
      });
    }

    console.log('ì‚¬ìš©ì ì§ˆë¬¸:', message);

    // "ë¶€ì‚°í•­" ê´€ë ¨ ì§ˆë¬¸ ì²˜ë¦¬ (í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ìœ„ì¹˜)
    if (message.toLowerCase().includes('ë¶€ì‚°í•­') && (message.includes('ì–´ë””ì„œ') || message.includes('ì–´ë””ì—ì„œ') || message.includes('í¬ë£¨ì¦ˆ'))) {
      // ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ìœ„ì¹˜ ì´ë¯¸ì§€ ì§ì ‘ ì œê³µ
      const busanTerminalImage = "/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ìœ„ì¹˜/ë¶€ì‚°í•­ MSC ë°¸ë¦¬ì‹œë§ˆ ìŠ¹í•˜ì„  ìœ„ì¹˜ ì§€ë„.png";
      
      return new NextResponse(JSON.stringify({
        text: 'ë¶€ì‚°ì—ì„œ í¬ë£¨ì¦ˆë¥¼ íƒ€ì‹œëŠ” ê³³ì€ ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ì…ë‹ˆë‹¤! ìœ„ì¹˜ë¥¼ ë³´ì—¬ë“œë¦´ê²Œìš”.',
        imageUrl: busanTerminalImage,
        photoAlbum: ["/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ìœ„ì¹˜/ë¶€ì‚°í•­ MSC ë°¸ë¦¬ì‹œë§ˆ ìŠ¹í•˜ì„  ìœ„ì¹˜ ì§€ë„.png", "/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ìœ„ì¹˜/ë¶€ì‚°í•­ ì½”íƒ€ì„¸ë ˆë‚˜í˜¸ ìŠ¹í•˜ì„  ìœ„ì¹˜ ì§€ë„.png"],
        suggestions: [
          'ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ êµí†µí¸',
          'ë¶€ì‚° í¬ë£¨ì¦ˆ í„°ë¯¸ë„ ì£¼ì°¨ì¥',
          'ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´'
        ],
        source: 'busan_terminal',
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
      });
    }

    // "í¬ë£¨ì¦ˆ" ë‹¨ë… ì§ˆë¬¸ ì²˜ë¦¬ (êµ¬ì²´ì ì¸ í¬ë£¨ì¦ˆì„  ì˜µì…˜ ì œê³µ)
    if (message.trim().toLowerCase() === 'í¬ë£¨ì¦ˆ') {
      return new NextResponse(JSON.stringify({
        text: 'ì–´ë–¤ í¬ë£¨ì¦ˆê°€ ê¶ê¸ˆí•´? ë³´ê³  ì‹¶ì€ í¬ë£¨ì¦ˆì„ ì„ ì„ íƒí•´ì£¼ì„¸ìš”!',
        suggestions: [
          'ì½”ìŠ¤íƒ€ ì„¸ë ˆë‚˜',
          'ë¡œì–„ ìºë¦¬ë¹„ì•ˆ', 
          'MSC ë²¨ë¦¬ì‹œë§ˆ'
        ],
        source: 'cruise_clarification',
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
      });
    }

    // "ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´" ì²˜ë¦¬ - ì‚¬ìš©ìì˜ ìƒˆë¡œìš´ ì§ˆë¬¸ì„ ë°›ê³  Geminië¡œ ì‘ë‹µ
    if (message.trim() === "ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´") {
      return new NextResponse(JSON.stringify({
        text: "ì§€ë‹ˆê°€ ê¶ê¸ˆí•œ ê²ƒì„ ë¬¼ì–´ë³´ì„¸ìš”! ğŸ˜ŠğŸ§â€â™‚ï¸ ë­ë“ ì§€ ë„ì™€ë“œë¦´ê²Œìš”!",
        suggestions: [
          "ì½”ìŠ¤íƒ€ ì„¸ë ˆë‚˜ í¬ë£¨ì¦ˆëŠ” ì–´ë–¤ê°€ìš”?",
          "ì¼ë³¸ ì—¬í–‰ì§€ ì¶”ì²œí•´ì£¼ì„¸ìš”",
          "í¬ë£¨ì¦ˆ ì¤€ë¹„ë¬¼ ì•Œë ¤ì£¼ì„¸ìš”"
        ],
        source: "genie_prompt",
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
      });
    }

    // "ì‚¬ì§„", "ì´ë¯¸ì§€" í‚¤ì›Œë“œ ì²˜ë¦¬ - í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„ í´ë”ì—ì„œ ê²€ìƒ‰
    if (message.includes("ì‚¬ì§„") || message.includes("ì´ë¯¸ì§€")) {
      const photoSearchResult = await searchPhotosInCruiseInfo(message);
      
      if (photoSearchResult.images.length > 0) {
        return new NextResponse(JSON.stringify({
          text: `ë„¤! ì‚¬ì§„ì„ ì°¾ì•„ë“œë¦´ê²Œìš”! ğŸ˜Š ì´ ${photoSearchResult.images.length}ì¥ì˜ ê´€ë ¨ ì‚¬ì§„ì´ ìˆì–´ìš”. ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ì„ ë³´ì—¬ë“œë¦´ê²Œìš”!`,
          imageUrl: photoSearchResult.images[0],
          photoAlbum: photoSearchResult.images,
          suggestions: [
            "ë” ë§ì€ ì‚¬ì§„ ë³´ê¸°",
          ],
          source: "photo_search",
          timestamp: new Date().toISOString()
        }), {
          headers: { "Content-Type": "application/json; charset=UTF-8" },
        });
      } else {
        return new NextResponse(JSON.stringify({
          text: `ì•„ì‰½ê²Œë„ ê´€ë ¨ ì‚¬ì§„ì„ ì°¾ì§€ ëª»í–ˆì–´ìš” ğŸ˜” í•˜ì§€ë§Œ ë‹¤ë¥¸ ì§ˆë¬¸ì„ í•´ì£¼ì‹œë©´ ë„ì™€ë“œë¦´ê²Œìš”!`,
          suggestions: [
            "ì½”ìŠ¤íƒ€ì„¸ë ˆë‚˜ ì‚¬ì§„ ë³´ì—¬ì¤˜",
            "MSC ë²¨ë¦¬ì‹œë§ˆ ì‚¬ì§„ ë³´ì—¬ì¤˜",
          ],
          source: "photo_not_found",
          timestamp: new Date().toISOString()
        }), {
          headers: { "Content-Type": "application/json; charset=UTF-8" },
        });
      }
    }

    // "ì§€ë„" í‚¤ì›Œë“œ ì²˜ë¦¬ - terminals.csvì—ì„œ ê²€ìƒ‰ í›„ êµ¬ê¸€ë§µ ë§í¬ ì œê³µ
    if (message.includes("ì§€ë„")) {
      const mapResult = await searchMapInfo(message);
      
      if (mapResult.found) {
        return new NextResponse(JSON.stringify({
          text: `ë„¤! ì§€ë„ ì •ë³´ë¥¼ ì°¾ì•˜ì–´ìš”! ğŸ—ºï¸ ${mapResult.location}ì— ëŒ€í•œ ì§€ë„ë¥¼ ë³´ì—¬ë“œë¦´ê²Œìš”.`,
          imageUrl: mapResult.imageUrl,
          photoAlbum: mapResult.imageUrl ? [mapResult.imageUrl] : [],
          suggestions: [
            "êµ¬ê¸€ë§µì—ì„œ ë³´ê¸°",
            "ë‹¤ë¥¸ ì§€ë„ ì°¾ê¸°",
            "ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´"
          ],
          googleMapsUrl: mapResult.googleMapsUrl,
          source: "map_search",
          timestamp: new Date().toISOString()
        }), {
          headers: { "Content-Type": "application/json; charset=UTF-8" },
        });
      } else {
        // terminals.csvì— ì—†ìœ¼ë©´ êµ¬ê¸€ë§µ ë§í¬ë§Œ ì œê³µ
        const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(message)}`;
        
        return new NextResponse(JSON.stringify({
          text: `ì£„ì†¡í•´ìš”, ì œê°€ ê°€ì§„ ì§€ë„ì—ëŠ” í•´ë‹¹ ì •ë³´ê°€ ì—†ë„¤ìš” ğŸ˜… í•˜ì§€ë§Œ êµ¬ê¸€ë§µì—ì„œ ì°¾ì•„ë³´ì‹¤ ìˆ˜ ìˆì–´ìš”!`,
          suggestions: [
            "êµ¬ê¸€ë§µì—ì„œ ë³´ê¸°",
            "ë‹¤ë¥¸ ì§€ë„ ì°¾ê¸°",
            "ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´"
          ],
          googleMapsUrl: googleMapsUrl,
          source: "google_maps_fallback",
          timestamp: new Date().toISOString()
        }), {
          headers: { "Content-Type": "application/json; charset=UTF-8" },
        });
      }
    }

    // 1. ì§€ëŠ¥í˜• ê³„ì¸µ ê²€ìƒ‰ ë¡œì§ ì‹¤í–‰
    const searchResult = await intelligentImageSearch(message);
    console.log('ê²€ìƒ‰ ê²°ê³¼:', searchResult);

    // 2. ì¡°ê±´ë¶€ ë‹µë³€ ìƒì„±
    if (searchResult.images.length > 0) {
      // ìë£Œ ìˆìŒ - ë‚´ë¶€ ì´ë¯¸ì§€ ê¸°ë°˜ ì‘ë‹µ
      const responseText = generateImageResponse(message, searchResult.keywords, searchResult.images.length, searchResult.searchType);
      
      return new NextResponse(JSON.stringify({
        text: responseText,
        imageUrl: searchResult.images[0], // ì²« ë²ˆì§¸ ì´ë¯¸ì§€
        photoAlbum: searchResult.images, // ì „ì²´ ì´ë¯¸ì§€ ëª©ë¡
        suggestions: [
          'ë” ë§ì€ ì‚¬ì§„ ë³´ê¸°',
          'ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´'
        ],
        source: 'internal_images',
        searchType: searchResult.searchType,
        timestamp: new Date().toISOString()
      }), {
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
      });
    } else {
      // ìë£Œ ì—†ìŒ - Gemini ì¼ë°˜ ì§€ì‹ í™œìš© (Gemini ì‹¤íŒ¨ ì‹œ ì¹œê·¼í•œ ì‘ë‹µ)
      try {
        const geminiResponse = await getGeminiResponse(message);
        
        return new NextResponse(JSON.stringify({
          text: `ìŒ... ê·¸ ì •ë³´ëŠ” ì œ ì‚¬ì§„ì²©ì—ëŠ” ì—†ë„¤ìš”. ëŒ€ì‹  ì™¸ë¶€ì—ì„œ ì°¾ì•„ë³¸ ì •ë³´ë¥¼ ì•Œë ¤ë“œë¦´ê²Œìš”!\n\n${geminiResponse}`,
          suggestions: [
            'ë‹¤ë¥¸ ì§ˆë¬¸í•˜ê¸°',
            'ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´'
          ],
          source: 'gemini',
          timestamp: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json; charset=UTF-8' },
        });
        
      } catch (geminiError) {
        console.error('Gemini ì˜¤ë¥˜:', geminiError);
        
        // Gemini ì‹¤íŒ¨ ì‹œì—ë„ ì¹œê·¼í•œ ì‘ë‹µ ì œê³µ
        return new NextResponse(JSON.stringify({
          text: `ìŒ... ê·¸ ì •ë³´ëŠ” ì œê°€ ì•„ì§ ë°°ìš°ì§€ ëª»í–ˆì–´ìš”. ğŸ˜¥\n\ní•˜ì§€ë§Œ ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ë¬¼ì–´ë³´ì„¸ìš”! ë‹¤ë¥¸ ì§ˆë¬¸ì„ í•´ì£¼ì‹œê² ì–´ìš”?`,
          suggestions: [
            'ì½”ìŠ¤íƒ€ì„¸ë ˆë‚˜ ë‚´ë¶€ ì‹œì„¤ ë³´ì—¬ì¤˜',
            'í¬ë£¨ì¦ˆ ì—¬í–‰ ì¤€ë¹„ë¬¼ ì•Œë ¤ì¤˜',
            'ì¼ë³¸ ê´€ê´‘ì§€ ì¶”ì²œí•´ì¤˜',
            'ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´'
          ],
          source: 'fallback',
          timestamp: new Date().toISOString()
        }), {
          headers: { 'Content-Type': 'application/json; charset=UTF-8' },
        });
      }
    }

  } catch (error) {
    console.error('Chat API ì „ì²´ ì˜¤ë¥˜:', error);
    
    return new NextResponse(JSON.stringify({
      text: 'ì•—, ì ì‹œ ë¬¸ì œê°€ ìƒê²¼ë„¤ìš”! ğŸ˜…\n\në‹¤ì‹œ ì‹œë„í•´ì£¼ì‹œê² ì–´ìš”?',
      suggestions: [
        'ë‹¤ì‹œ ì‹œë„í•˜ê¸°',
        'ì§€ë‹ˆì•¼ ê¶ê¸ˆí•œê±° ë¬¼ì–´ë³´ê³ ì‹¶ì–´'
      ],
      source: 'error',
      timestamp: new Date().toISOString()
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json; charset=UTF-8' },
    });
  }
});

// ì§€ëŠ¥í˜• ê³„ì¸µ ê²€ìƒ‰ í•¨ìˆ˜
async function intelligentImageSearch(message: string): Promise<{
  images: string[];
  keywords: string[];
  searchType: string;
}> {
  try {
    const photosDir = path.join(process.cwd(), 'public', 'í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„');
    
    // ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    if (!fs.existsSync(photosDir)) {
      console.log('í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      return { images: [], keywords: [], searchType: 'none' };
    }

    // 1ìˆœìœ„: ì™„ì „ ì¼ì¹˜ ê²€ìƒ‰
    const exactMatchResult = await searchExactMatch(message, photosDir);
    if (exactMatchResult.images.length > 0) {
      console.log('1ìˆœìœ„ ì™„ì „ ì¼ì¹˜ ê²€ìƒ‰ ì„±ê³µ:', exactMatchResult.keywords);
      return { ...exactMatchResult, searchType: 'exact_match' };
    }

    // 2ìˆœìœ„: ëª¨ë“  ë‹¨ì–´ í¬í•¨ ê²€ìƒ‰ (AND ê²€ìƒ‰)
    const allWordsResult = await searchAllWords(message, photosDir);
    if (allWordsResult.images.length > 0) {
      console.log('2ìˆœìœ„ ëª¨ë“  ë‹¨ì–´ í¬í•¨ ê²€ìƒ‰ ì„±ê³µ:', allWordsResult.keywords);
      return { ...allWordsResult, searchType: 'all_words' };
    }

    // 3ìˆœìœ„: í•µì‹¬ ë‹¨ì–´ ê²€ìƒ‰ (ë§ˆì§€ë§‰ ë‹¨ì–´)
    const coreWordResult = await searchCoreWord(message, photosDir);
    if (coreWordResult.images.length > 0) {
      console.log('3ìˆœìœ„ í•µì‹¬ ë‹¨ì–´ ê²€ìƒ‰ ì„±ê³µ:', coreWordResult.keywords);
      return { ...coreWordResult, searchType: 'core_word' };
    }

    // 4ìˆœìœ„: ì–´ëŠ ë‹¨ì–´ë“  í¬í•¨ ê²€ìƒ‰ (OR ê²€ìƒ‰)
    const anyWordResult = await searchAnyWord(message, photosDir);
    console.log('4ìˆœìœ„ ì–´ëŠ ë‹¨ì–´ë“  í¬í•¨ ê²€ìƒ‰ ê²°ê³¼:', anyWordResult.keywords);
    return { ...anyWordResult, searchType: 'any_word' };
    
  } catch (error) {
    console.error('ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    return { images: [], keywords: [], searchType: 'error' };
  }
}

// 1ìˆœìœ„: ì™„ì „ ì¼ì¹˜ ê²€ìƒ‰
async function searchExactMatch(message: string, photosDir: string): Promise<{
  images: string[];
  keywords: string[];
}> {
  const keywords: string[] = [];
  const messageLower = message.toLowerCase();
  
  // ë„ì–´ì“°ê¸° ì—†ëŠ” í•µì‹¬ ë‹¨ì–´ë“¤ ì¶”ì¶œ
  const exactKeywords = [
    'í”¼ì•„ë…¸ëœë“œ', 'pianoland',
    'ì½”ìŠ¤íƒ€ì„¸ë ˆë‚˜', 'costaserena', 'costa serena',
    'mscë°¸ë¦¬ì‹œë§ˆ', 'mscë°¸ë¦¬ì‹œë§ˆ', 'msc bellissima',
    'ë²¨ë¦¬ì‹œë§ˆí¬ë£¨ì¦ˆ', 'bellissimacruise',
    'ì•„ì´ì˜¤ë‚˜', 'iona',
    'í€€í…€', 'quantum',
    'ë¯¸ì•¼ì½”ì§€ë§ˆ', 'miyakojima',
    'ì‚¬ì„¸ë³´', 'sasebo',
    'ë„ì¿„', 'tokyo',
    'ì˜¤ì‚¬ì¹´', 'osaka',
    'í™ì½©', 'hong kong',
    'ì‹±ê°€í¬ë¥´', 'singapore',
    'ë² íŠ¸ë‚¨', 'vietnam',
    'ì¤‘êµ­', 'china'
  ];
  
  // ì™„ì „ ì¼ì¹˜ í‚¤ì›Œë“œ ì°¾ê¸°
  for (const keyword of exactKeywords) {
    if (messageLower.includes(keyword.toLowerCase())) {
      keywords.push(keyword);
    }
  }
  
  if (keywords.length === 0) {
    return { images: [], keywords: [] };
  }
  
  const images = await searchImagesByKeywords(keywords, photosDir);
  return { images, keywords };
}

// 2ìˆœìœ„: ëª¨ë“  ë‹¨ì–´ í¬í•¨ ê²€ìƒ‰ (AND ê²€ìƒ‰)
async function searchAllWords(message: string, photosDir: string): Promise<{
  images: string[];
  keywords: string[];
}> {
  // ì§ˆë¬¸ì„ ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê¸° (ë„ì–´ì“°ê¸°, ì‰¼í‘œ, ë¬¼ìŒí‘œ ë“±ìœ¼ë¡œ ë¶„ë¦¬)
  const words = message.toLowerCase()
    .replace(/[.,!?]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 1); // 1ê¸€ì ë‹¨ì–´ ì œì™¸
  
  if (words.length < 2) {
    return { images: [], keywords: [] };
  }
  
  const images = await searchImagesByAllWords(words, photosDir);
  return { images, keywords: words };
}

// 3ìˆœìœ„: í•µì‹¬ ë‹¨ì–´ ê²€ìƒ‰ (ë§ˆì§€ë§‰ ë‹¨ì–´)
async function searchCoreWord(message: string, photosDir: string): Promise<{
  images: string[];
  keywords: string[];
}> {
  // ì§ˆë¬¸ì„ ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê¸°
  const words = message.toLowerCase()
    .replace(/[.,!?]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 1);
  
  if (words.length === 0) {
    return { images: [], keywords: [] };
  }
  
  // ê°€ì¥ ë§ˆì§€ë§‰ ë‹¨ì–´ë¥¼ í•µì‹¬ ë‹¨ì–´ë¡œ ì‚¬ìš©
  const coreWord = words[words.length - 1];
  const images = await searchImagesByKeywords([coreWord], photosDir);
  
  return { images, keywords: [coreWord] };
}

// 4ìˆœìœ„: ì–´ëŠ ë‹¨ì–´ë“  í¬í•¨ ê²€ìƒ‰ (OR ê²€ìƒ‰)
async function searchAnyWord(message: string, photosDir: string): Promise<{
  images: string[];
  keywords: string[];
}> {
  // ì§ˆë¬¸ì„ ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê¸°
  const words = message.toLowerCase()
    .replace(/[.,!?]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 1);
  
  if (words.length === 0) {
    return { images: [], keywords: [] };
  }
  
  const images = await searchImagesByAnyWord(words, photosDir);
  return { images, keywords: words };
}

// í‚¤ì›Œë“œë¡œ ì´ë¯¸ì§€ ê²€ìƒ‰ (ì™„ì „ ì¼ì¹˜ìš©)
async function searchImagesByKeywords(keywords: string[], photosDir: string): Promise<string[]> {
  const foundImages: string[] = [];
  
  function searchDirectory(dirPath: string, relativePath: string = '') {
    const items = fs.readdirSync(dirPath);
    
    for (const item of items) {
      const itemPath = path.join(dirPath, item);
      const itemRelativePath = path.join(relativePath, item);
      const stat = fs.statSync(itemPath);
      
      if (stat.isDirectory()) {
        searchDirectory(itemPath, itemRelativePath);
      } else if (stat.isFile()) {
        const ext = path.extname(item).toLowerCase();
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
        const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv'];
        
        if (imageExtensions.includes(ext) || videoExtensions.includes(ext)) {
          const fileName = item.toLowerCase();
          const hasKeyword = keywords.some(keyword => 
            fileName.includes(keyword.toLowerCase())
          );
          
          if (hasKeyword) {
            foundImages.push(`/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/${itemRelativePath.replace(/\\/g, '/')}`);
          }
        }
      }
    }
  }
  
  searchDirectory(photosDir);
  return foundImages;
}

// ëª¨ë“  ë‹¨ì–´ê°€ í¬í•¨ëœ ì´ë¯¸ì§€ ê²€ìƒ‰ (AND ê²€ìƒ‰)
async function searchImagesByAllWords(words: string[], photosDir: string): Promise<string[]> {
  const foundImages: string[] = [];
  
  function searchDirectory(dirPath: string, relativePath: string = '') {
    const items = fs.readdirSync(dirPath);
    
    for (const item of items) {
      const itemPath = path.join(dirPath, item);
      const itemRelativePath = path.join(relativePath, item);
      const stat = fs.statSync(itemPath);
      
      if (stat.isDirectory()) {
        searchDirectory(itemPath, itemRelativePath);
      } else if (stat.isFile()) {
        const ext = path.extname(item).toLowerCase();
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
        const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv'];
        
        if (imageExtensions.includes(ext) || videoExtensions.includes(ext)) {
          const fileName = item.toLowerCase();
          // ëª¨ë“  ë‹¨ì–´ê°€ í¬í•¨ë˜ì–´ì•¼ í•¨ (AND ì¡°ê±´)
          const hasAllWords = words.every(word => 
            fileName.includes(word.toLowerCase())
          );
          
          if (hasAllWords) {
            foundImages.push(`/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/${itemRelativePath.replace(/\\/g, '/')}`);
          }
        }
      }
    }
  }
  
  searchDirectory(photosDir);
  return foundImages;
}

// ì–´ëŠ ë‹¨ì–´ë“  í¬í•¨ëœ ì´ë¯¸ì§€ ê²€ìƒ‰ (OR ê²€ìƒ‰)
async function searchImagesByAnyWord(words: string[], photosDir: string): Promise<string[]> {
  const foundImages: string[] = [];
  
  function searchDirectory(dirPath: string, relativePath: string = '') {
    const items = fs.readdirSync(dirPath);
    
    for (const item of items) {
      const itemPath = path.join(dirPath, item);
      const itemRelativePath = path.join(relativePath, item);
      const stat = fs.statSync(itemPath);
      
      if (stat.isDirectory()) {
        searchDirectory(itemPath, itemRelativePath);
      } else if (stat.isFile()) {
        const ext = path.extname(item).toLowerCase();
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
        const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv'];
        
        if (imageExtensions.includes(ext) || videoExtensions.includes(ext)) {
          const fileName = item.toLowerCase();
          // ë‹¨ì–´ ì¤‘ í•˜ë‚˜ë¼ë„ í¬í•¨ë˜ë©´ ë¨ (OR ì¡°ê±´)
          const hasAnyWord = words.some(word => 
            fileName.includes(word.toLowerCase())
          );
          
          if (hasAnyWord) {
            foundImages.push(`/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/${itemRelativePath.replace(/\\/g, '/')}`);
          }
        }
      }
    }
  }
  
  searchDirectory(photosDir);
  return foundImages;
}

// ì´ë¯¸ì§€ ê¸°ë°˜ ì‘ë‹µ ìƒì„± í•¨ìˆ˜
function generateImageResponse(message: string, keywords: string[], imageCount: number, searchType: string): string {
  const messageLower = message.toLowerCase();
  
  let baseResponse = '';
  
  // ê²€ìƒ‰ íƒ€ì…ì— ë”°ë¥¸ ì‘ë‹µ
  switch (searchType) {
    case 'exact_match':
      baseResponse = `ì™€! ì •í™•íˆ ì°¾ì•˜ì–´ìš”! ğŸ˜Š ${keywords.join(', ')}ì— ëŒ€í•œ ì‚¬ì§„ì„ ì°¾ì•˜ì–´ìš”!`;
      break;
    case 'all_words':
      baseResponse = `ì™€! .* ëª¨ë‘ í¬í•¨ëœ ì‚¬ì§„ì„ ì°¾ì•˜ì–´ìš”! ğŸ˜Š`;
      break;
    case 'core_word':
      baseResponse = `ì™€! .* ê´€ë ¨ ì‚¬ì§„ì„ ì°¾ì•˜ì–´ìš”! ğŸ˜Š`;
      break;
    case 'any_word':
      baseResponse = `ì™€! .* ì¤‘ ì¼ë¶€ì™€ ê´€ë ¨ëœ ì‚¬ì§„ì„ ì°¾ì•˜ì–´ìš”! ğŸ˜Š`;
      break;
    default:
      baseResponse = `ì™€! ê´€ë ¨ ì‚¬ì§„ì„ ì°¾ì•˜ì–´ìš”! ğŸ˜Š`;
  }
  
  // ì§ˆë¬¸ ìœ í˜•ì— ë”°ë¥¸ ì¶”ê°€ ì„¤ëª…
  if (messageLower.includes('ë‚´ë¶€') || messageLower.includes('ì‹œì„¤')) {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  } else if (messageLower.includes('ì™¸ê´€') || messageLower.includes('ì™¸ë¶€')) {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  } else if (messageLower.includes('ê°ì‹¤')) {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  } else if (messageLower.includes('ë ˆìŠ¤í† ë‘')) {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  } else if (messageLower.includes('ìˆ˜ì˜ì¥')) {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  } else {
    return `${baseResponse} ë¨¼ì € ëŒ€í‘œì ì¸ ì‚¬ì§„ í•œ ì¥ì„ ë³´ì—¬ë“œë¦´ê²Œìš”. ì´ ${imageCount}ì¥ì˜ ì‚¬ì§„ì´ ìˆì–´ìš”.`;
  }
}

// Gemini ì‘ë‹µ ìƒì„± í•¨ìˆ˜
async function getGeminiResponse(message: string): Promise<string> {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

    const systemPrompt = `ë‹¹ì‹ ì€ 100ë²ˆ ì´ìƒ í¬ë£¨ì¦ˆë¥¼ íƒ„ ì¹œê·¼í•œ ì „ë¬¸ê°€ 'ì§€ë‹ˆ'ì…ë‹ˆë‹¤.

ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— ëŒ€í•´ ì¹œê·¼í•˜ê³  ë„ì›€ì´ ë˜ëŠ” ë‹µë³€ì„ í•´ì£¼ì„¸ìš”.

**ë‹µë³€ ê·œì¹™**:
1. ì¹œê·¼í•˜ê³  ë”°ëœ»í•œ í†¤ìœ¼ë¡œ ë‹µë³€í•˜ì„¸ìš”
2. êµ¬ì²´ì ì´ê³  ì‹¤ìš©ì ì¸ ì •ë³´ë¥¼ ì œê³µí•˜ì„¸ìš”
3. í¬ë£¨ì¦ˆ ì—¬í–‰ ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ í•œ ì¡°ì–¸ì„ í¬í•¨í•˜ì„¸ìš”
4. ë‹µë³€ ë§ˆì§€ë§‰ì— "ê¶ê¸ˆí•œ ì ì´ ë” ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ë¬¼ì–´ë³´ì„¸ìš”! ğŸ§â€â™‚ï¸"ë¼ê³  ë§ˆë¬´ë¦¬í•˜ì„¸ìš”
5. ì ˆëŒ€ ì½”ë“œë‚˜ ê¸°ìˆ ì ì¸ ë‚´ìš©ì€ í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”
6. ì¥ì†Œ ê´€ë ¨ ì§ˆë¬¸ì¼ ê²½ìš° êµ¬ê¸€ë§µ ë§í¬ë¥¼ í¬í•¨í•˜ì„¸ìš”
7. **ì¤‘ìš”**: ë§Œì•½ ì‚¬ìš©ìì˜ ì´ë¯¸ì§€ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ì„ ê²½ìš°, ê·¸ëƒ¥ 'ì—†ìŠµë‹ˆë‹¤'ë¼ê³  ë§í•˜ì§€ ë§ê³ , 'ìŒ... ê·¸ ì‚¬ì§„ì€ ì œ ì•¨ë²”ì— ì—†ë„¤ìš”. í˜¹ì‹œ 'ì½”ìŠ¤íƒ€ ì„¸ë ˆë‚˜' ì²˜ëŸ¼ êµ¬ì²´ì ì¸ í¬ë£¨ì¦ˆì„  ì´ë¦„ìœ¼ë¡œ ë‹¤ì‹œ ë¬¼ì–´ë³´ì‹œê² ì–´ìš”?' ì™€ ê°™ì´ **ë” ì¢‹ì€ ê²€ìƒ‰ ë°©ë²•ì„ ì¹œì ˆí•˜ê²Œ ì•ˆë‚´**í•´ì¤˜.

ì‚¬ìš©ì ì§ˆë¬¸: ${message}`;

    const result = await model.generateContent(systemPrompt);
    const response = result.response.text();

    return response;

  } catch (error) {
    console.error('Gemini ì‘ë‹µ ìƒì„± ì˜¤ë¥˜:', error);
    throw error;
  }
}

// í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„ í´ë”ì—ì„œ ì‚¬ì§„ ê²€ìƒ‰ í•¨ìˆ˜
async function searchPhotosInCruiseInfo(message: string): Promise<{ images: string[] }> {
  try {
    const photosDir = path.join(process.cwd(), 'public', 'í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„');
    
    if (!fs.existsSync(photosDir)) {
      return { images: [] };
    }

    const foundImages: string[] = [];
    
    function searchDirectory(dirPath: string, relativePath: string = '') {
      const items = fs.readdirSync(dirPath);
      
      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const itemRelativePath = path.join(relativePath, item);
        const stat = fs.statSync(itemPath);
        
        if (stat.isDirectory()) {
          searchDirectory(itemPath, itemRelativePath);
        } else if (stat.isFile()) {
          const ext = path.extname(item).toLowerCase();
          const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
          const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv'];
          
          if (imageExtensions.includes(ext) || videoExtensions.includes(ext)) {
            // ì‚¬ì§„/ì´ë¯¸ì§€ í‚¤ì›Œë“œê°€ í¬í•¨ëœ íŒŒì¼ëª… ê²€ìƒ‰
            const fileName = item.toLowerCase();
            const messageLower = message.toLowerCase();
            
            // ë©”ì‹œì§€ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì‚¬ì§„, ì´ë¯¸ì§€ ì œì™¸)
            const keywords = messageLower
              .replace(/[ì‚¬ì§„|ì´ë¯¸ì§€]/g, '')
              .replace(/[.,!?]/g, ' ')
              .split(/\s+/)
              .filter(word => word.length > 1);
            
            // í‚¤ì›Œë“œ ì¤‘ í•˜ë‚˜ë¼ë„ íŒŒì¼ëª…ì— í¬í•¨ë˜ë©´ ì¶”ê°€
            const hasKeyword = keywords.some(keyword => 
              fileName.includes(keyword.toLowerCase())
            );
            
            if (hasKeyword) {
              foundImages.push(`/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/${itemRelativePath.replace(/\\/g, '/')}`);
            }
          }
        }
      }
    }
    
    searchDirectory(photosDir);
    return { images: foundImages };
    
  } catch (error) {
    console.error('ì‚¬ì§„ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    return { images: [] };
  }
}

// ì§€ë„ ì •ë³´ ê²€ìƒ‰ í•¨ìˆ˜ (terminals.csvì—ì„œ ê²€ìƒ‰)
async function searchMapInfo(message: string): Promise<{
  found: boolean;
  location?: string;
  imageUrl?: string;
  googleMapsUrl?: string;
}> {
  try {
    // terminals.csv íŒŒì¼ ì½ê¸°
    const terminalsPath = path.join(process.cwd(), 'public', 'terminals.csv');
    
    if (!fs.existsSync(terminalsPath)) {
      // terminals.csvê°€ ì—†ìœ¼ë©´ êµ¬ê¸€ë§µ ë§í¬ë§Œ ì œê³µ
      const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(message)}`;
      return {
        found: false,
        googleMapsUrl: googleMapsUrl
      };
    }

    const csvContent = fs.readFileSync(terminalsPath, 'utf-8');
    const lines = csvContent.split('\n');
    
    // CSV í—¤ë” ì œê±°
    const dataLines = lines.slice(1).filter(line => line.trim());
    
    // ë©”ì‹œì§€ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì§€ë„ ì œì™¸)
    const messageLower = message.toLowerCase();
    const keywords = messageLower
      .replace(/[ì§€ë„]/g, '')
      .replace(/[.,!?]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 1);
    
    for (const line of dataLines) {
      const columns = line.split(',');
      if (columns.length >= 3) {
        const city = columns[0]?.trim().toLowerCase();
        const country = columns[1]?.trim().toLowerCase();
        const description = columns[2]?.trim().toLowerCase();
        
        // í‚¤ì›Œë“œì™€ ë§¤ì¹­ë˜ëŠ”ì§€ í™•ì¸
        const hasMatch = keywords.some(keyword => 
          city?.includes(keyword) || 
          country?.includes(keyword) || 
          description?.includes(keyword)
        );
        
        if (hasMatch) {
          // í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„ í´ë”ì—ì„œ í•´ë‹¹ ì§€ë„ ì´ë¯¸ì§€ ì°¾ê¸°
          const mapImagePath = await findMapImage(city, country, description);
          
          const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(message)}`;
          
          return {
            found: true,
            location: `${columns[0]} ${columns[1]}`,
            imageUrl: mapImagePath,
            googleMapsUrl: googleMapsUrl
          };
        }
      }
    }
    
    // ë§¤ì¹­ë˜ëŠ” í•­ëª©ì´ ì—†ìœ¼ë©´ êµ¬ê¸€ë§µ ë§í¬ë§Œ ì œê³µ
    const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(message)}`;
    return {
      found: false,
      googleMapsUrl: googleMapsUrl
    };
    
  } catch (error) {
    console.error('ì§€ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    const googleMapsUrl = `https://www.google.com/maps/search/${encodeURIComponent(message)}`;
    return {
      found: false,
      googleMapsUrl: googleMapsUrl
    };
  }
}

// ì§€ë„ ì´ë¯¸ì§€ ì°¾ê¸° í•¨ìˆ˜
async function findMapImage(city: string, country: string, description: string): Promise<string | undefined> {
  try {
    const photosDir = path.join(process.cwd(), 'public', 'í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„');
    
    if (!fs.existsSync(photosDir)) {
      return undefined;
    }

    function searchDirectory(dirPath: string, relativePath: string = '') {
      const items = fs.readdirSync(dirPath);
      
      for (const item of items) {
        const itemPath = path.join(dirPath, item);
        const itemRelativePath = path.join(relativePath, item);
        const stat = fs.statSync(itemPath);
        
        if (stat.isDirectory()) {
          const result = searchDirectory(itemPath, itemRelativePath);
          if (result) return result;
        } else if (stat.isFile()) {
          const ext = path.extname(item).toLowerCase();
          const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
          
          if (imageExtensions.includes(ext)) {
            const fileName = item.toLowerCase();
            
            // ì§€ë„ ê´€ë ¨ í‚¤ì›Œë“œê°€ í¬í•¨ëœ íŒŒì¼ëª… ê²€ìƒ‰
            const hasMapKeyword = fileName.includes('ì§€ë„') || 
                                 fileName.includes('map') || 
                                 fileName.includes('í„°ë¯¸ë„') ||
                                 fileName.includes('terminal');
            
            // ë„ì‹œ/êµ­ê°€ëª…ì´ í¬í•¨ëœ íŒŒì¼ëª… ê²€ìƒ‰
            const hasLocationKeyword = (city && fileName.includes(city)) ||
                                      (country && fileName.includes(country));
            
            if (hasMapKeyword && hasLocationKeyword) {
              return `/í¬ë£¨ì¦ˆì •ë³´ì‚¬ì§„/${itemRelativePath.replace(/\\/g, '/')}`;
            }
          }
        }
      }
      return undefined;
    }
    
    return searchDirectory(photosDir);
    
  } catch (error) {
    console.error('ì§€ë„ ì´ë¯¸ì§€ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    return undefined;
  }
}
